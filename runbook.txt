Project: Repo Mechanic — An Agentic Code Fixer for Python Repos

A local “agentic” CLI that:

reads any small Python repo,

plans fixes for failing tests or lints,

executes tool-calls (pytest, ruff/black, pip) in a sandbox,

proposes an edit plan, applies patches, re-runs checks,

writes a human-readable “Receipts” log explaining what it did and why.

No cloud required to demo core agent loops. Works offline on a sample repo. Clean, auditable tool use. This shows agent planning, tool invocation, memory, evaluation loops, and guardrails—exactly what “agentic coding” interviews look for.

Why this repo works for hiring

Demonstrates agent patterns: planner → tool registry → execution → reflection → persistence.

Auditable: every step logged as “Receipts” (inputs, plan, actions, diffs, outcomes).

Safe and local: sandboxes changes, never touches global env.

Extensible: start with Python/pytest; later add Node/Jest to show breadth.

Codex-friendly: bite-size tasks, clear APIs, deterministic scaffolding.

Minimal Feature Set (MVP)

CLI: repo-mechanic <path-to-repo>
Flags: --fix-tests, --lint, --dry-run, --max-steps 10

Planner: static heuristic planner (no LLM required for MVP) that reads:

failing pytest -q output

linter output (ruff/black)

repo structure + requirements.txt
Produces a step plan (edit files X/Y, run ruff, re-run tests).

Tool Registry (pure functions):

run_pytest(), run_ruff(), run_black(), pip_install()

apply_patch(file, unified_diff) with safety checks

git_init_branch(), git_commit_all(msg)

Memory & Receipts:

receipts/ folder per run with JSONL steps + a Markdown summary.

state.sqlite (or state.json) for last actions & outcomes.

Sandbox:

Local venv creation per target repo: .mechanic/.venv

Optional: Docker mode later.

Sample Target Repo:

fixtures/broken-calculator/ with 5–8 tests, 2 failing; simple lints.

Mechanic should fix it end-to-end in ≤10 steps.

Nice-to-Have (Phase 2)

Reflection loop: if tests still fail, adjust plan up to --max-steps.

Patch explainer: auto-generate a short rationale per diff hunk.

PR generator: on a real git repo, create a branch with commits and an optional PR body (local only).

Node support: detect package.json, run npm test, eslint, prettier.

Repo Structure
repo-mechanic/
  README.md
  LICENSE
  CONTRIBUTING.md
  .editorconfig
  pyproject.toml              # uv or poetry; ruff/black config too
  src/mechanic/
    __init__.py
    cli.py                    # argparse/typer
    planner.py                # static heuristic planner
    tools/
      shell.py                # safe subprocess wrapper
      pytest_tool.py
      ruff_tool.py
      black_tool.py
      pip_tool.py
      git_tool.py
    sandbox.py                # venv create/activate, path mgmt
    patches.py                # safe unified diff apply + guards
    receipts.py               # JSONL + Markdown summarizer
    memory.py                 # tiny sqlite/json state
    guards.py                 # file allowlist, max patch size, etc.
  tests/
    test_planner.py
    test_receipts.py
    test_patches.py
  fixtures/
    broken-calculator/        # sample “target” repo
      calc/
        __init__.py
        ops.py                # intentional bugs
      tests/
        test_ops.py           # 2 failing tests
      pyproject.toml
      requirements.txt
  scripts/
    demo.sh                   # run a full demo end-to-end
  .github/
    workflows/ci.yml          # run mechanic’s own tests & lint
    ISSUE_TEMPLATE.md
    PULL_REQUEST_TEMPLATE.md

Tech choices (hirers like seeing these)

Python 3.11+, Typer for CLI (or argparse), ruff + black, pytest.

uv or poetry for deterministic installs.

No external LLM in MVP → shows you understand agentic loops without magic.

README Outline (useful for recruiters)

What is Repo Mechanic? 2–3 sentences.

Why it matters (agentic coding patterns, safe tool use, receipts).

Quickstart

uv sync          # or: pipx install uv; then: uv sync
uv run repo-mechanic fixtures/broken-calculator --fix-tests


How it works (diagram of Planner→Tools→Receipts).

Design principles (auditability, idempotence, guardrails).

Extending to Node (Phase 2 section).

Demo (asciinema GIF + sample receipts link).

Security (what it will/won’t touch).

Roadmap (issues + milestones).

Guardrails you’ll implement (interview candy)

File allowlist (only edits inside target repo under /calc or /src).

Max patch size per step (e.g., 200 lines).

Dry-run mode produces diffs but doesn’t write them.

Every tool call logged with args, exit code, captured stdout/err.

If tests regress vs previous step → auto-revert last patch.

Milestones & Issues (Codex-friendly plan)

Milestone 0: Scaffolding (2–4 small issues)

init pyproject, repo tree, CI

create fixtures/broken-calculator

implement receipts writer (JSONL + MD)

Milestone 1: Core Tools (5–7 issues)

safe subprocess wrapper

pytest_tool (detect, run, parse failures)

ruff_tool, black_tool

pip_tool (create venv, install reqs)

git_tool (init, commit, create branch)

sandbox (venv paths, activation helper)

Milestone 2: Planner MVP (4–6 issues)

parse pytest failures → file:line hints

rank candidate fixes (lint first, then smallest edit files)

step plan serialization to receipts

dry-run vs write mode

Milestone 3: Patch Engine (4–6 issues)

unified diff apply with sanity checks

mini “edit recipe” (e.g., rename variable, add missing import)

re-run tests; log outcomes; stop on green

Milestone 4: UX & Docs (3–5 issues)

CLI polish (typer), help text

demo script & GIF

README deep dive, architecture diagram

Milestone 5: Reflection & Recovery (optional)

simple reflection: if still failing, try next recipe

auto-revert on regression

branch + commit message templates

Tip: create all issues up-front in GitHub with clear acceptance criteria. Codex can then “pick an issue” and implement it.

Demo Script (what reviewers will try)
git clone your/repo-mechanic && cd repo-mechanic
uv sync
uv run repo-mechanic fixtures/broken-calculator --fix-tests --max-steps 6
# Observe: receipts/2025-10-02*/summary.md
pytest -q fixtures/broken-calculator


Outcome: both failing tests now pass; ruff/black applied; receipts show what changed.

Stretch: “LLM mode” (branch later)

Once MVP is green, add an optional --llm flag that:

uses a local template to propose patch diffs from test errors,

still routes through the same guards and receipts,

never writes without diff approval (auto-approve in demo).

This separates agent orchestration (your strength) from model cleverness.

*******************************************


Put these files in your repo (top level)
.agents/
  system.md              # Non-negotiables: principles, guardrails, style
  project_brief.md       # One-page WHAT/WHY for the whole project
  constraints.md         # Hard limits (security, file write allowlist, patch size)
  tools.md               # What external tools are allowed and how to call them
  milestones.md          # The plan, broken into bite-sized issues
  acceptance.md          # “Done” checklists per milestone
  glossary.md            # Terms so the model uses your wording

tasks/
  001_scaffold.md
  002_tool_registry.md
  003_planner_mvp.md
  004_patch_engine.md
  005_receipts_and_docs.md

bootstrap/
  prompt.txt             # One message you can paste to kick off the session
  files.list             # The exact files to load as context first
  run.sh                 # Helper that prints the right snippets for easy copy/paste

Minimal contents (copy/paste these)
.agents/system.md
# System Rules (Non-negotiable)
- Operate as an agentic coder that plans → executes tools → verifies → logs receipts.
- Never run commands that modify files outside the repo.
- Only propose patches as unified diffs; keep changes minimal and reversible.
- Always re-run tests/lints after a change. If regressions occur, revert.
- Write clear commit messages and a short rationale for each patch.

.agents/project_brief.md
# Repo Mechanic — Local Agentic Code Fixer (MVP)
Goal: A CLI that reads a small Python repo, plans fixes for failing tests/lints,
applies minimal patches with guardrails, re-runs checks, and writes human-readable receipts.
No cloud is required for MVP. Python 3.11+, pytest, ruff, black, uv or poetry.

.agents/constraints.md
# Constraints
- Edit allowlist: src/**, tests/** in this repo only.
- Max patch size per step: 200 lines changed.
- Must create or reuse a local venv under .mechanic/.venv for target repos.
- All tool calls logged with args, exit code, and stdout/stderr in receipts/.

.agents/tools.md
# Approved Tool Calls
- pytest: run tests quietly; parse failures (file:line, message).
- ruff / black: lint/format; do not auto-fix unless instructed.
- pip (via uv/poetry): create isolated venv per target; install requirements.
- git: init, branch, commit; never push.

.agents/milestones.md
# Milestones
1) Scaffolding: CLI skeleton, receipts writer, fixtures/broken-calculator.
2) Tool registry: safe subprocess wrapper; pytest/ruff/black/pip/git adapters.
3) Planner MVP: parse test output; produce step plan; dry-run and write modes.
4) Patch engine: apply unified diffs safely; re-run checks; stop on green.
5) UX & docs: Typer CLI help, demo script, README, architecture diagram.

.agents/acceptance.md
# Acceptance (extract this into PR checklists)
- M1: `uv run pytest -q` passes for mechanic’s own tests; README quickstart works.
- M2: Each adapter returns structured results; errors captured in receipts/.
- M3: On the sample broken-calculator, plan shows at least 3 actionable steps.
- M4: After applying minimal patches, all fixture tests pass; no regressions.
- M5: Demo script produces receipts/*/summary.md with diffs + rationale.

tasks/001_scaffold.md
# Task 001 — Scaffold
Objectives:
- Create pyproject.toml with ruff/black/pytest config.
- Add src/mechanic/{cli.py,planner.py,receipts.py,tools/*.py}.
- Add tests/ for receipts + patches.
- Add fixtures/broken-calculator with 2 failing tests.

Deliverables:
- `uv sync` works; `pytest -q` runs (even if failing for fixtures).
- README quickstart section drafted.

Work rules:
- Show diffs in unified format per file. Keep functions small and typed.


(Repeat similarly brief, concrete instructions for 002–005.)

bootstrap/prompt.txt
You are my agentic coding assistant. Load and follow the repository rules and plan.

First, read these files in order:
- .agents/system.md
- .agents/project_brief.md
- .agents/constraints.md
- .agents/tools.md
- .agents/milestones.md
- .

*********************************************

Runbook: Build “Repo Mechanic” with Codex
0) One-time setup
# choose a workspace folder
mkdir -p ~/code && cd ~/code
git config --global init.defaultBranch main

# create project
mkdir repo-mechanic && cd repo-mechanic
git init

1) Seed the “rules” Codex will follow

Create the agent rules and tasks so Codex can read them.

mkdir -p .agents tasks bootstrap src/mechanic/tools tests fixtures/broken-calculator/{calc,tests} .github/workflows scripts


Create these files (paste the content verbatim):

.agents/system.md
# System Rules (Non-negotiable)
- Act as an agentic coder: plan → run tools → verify → log receipts.
- Never modify files outside this repo; respect edit allowlist (src/**, tests/**, fixtures/**).
- Propose code changes as unified diffs; keep changes minimal and reversible.
- Re-run tests/lints after each patch. If regressions occur, revert the last patch.
- For each step, write a short rationale and a clear commit message.

.agents/project_brief.md
# Repo Mechanic — Local Agentic Code Fixer (MVP)
Goal: A CLI that reads a small Python repo, plans fixes for failing tests/lints,
applies minimal patches with guardrails, re-runs checks, and writes human-readable receipts.
Stack: Python 3.11+, Typer CLI, pytest, ruff, black, uv (or poetry). No cloud needed.

.agents/constraints.md
# Constraints
- Edit allowlist: src/**, tests/**, fixtures/** in this repo only.
- Max patch size per step: 200 changed lines.
- Tool calls logged (args, exit code, stdout/stderr) into receipts/.
- Use local venv via uv for reproducibility.

.agents/tools.md
# Approved Tools
- pytest -q         : run tests, parse failures (file:line, message)
- ruff, black       : lint/format
- uv                : dependency/venv manager
- git               : init, branch, commit (never push)

.agents/milestones.md
# Milestones
1) Scaffold: pyproject, CLI skeleton, receipts writer, fixtures/broken-calculator.
2) Tool adapters: safe subprocess wrapper; pytest/ruff/black/uv/git adapters.
3) Planner MVP: parse test output, produce step plan; dry-run + write modes.
4) Patch engine: apply unified diffs with guards; re-run checks; stop on green.
5) UX & docs: Typer help, demo script, README, architecture diagram.

.agents/acceptance.md
# Acceptance
- M1: `uv run pytest -q` executes; README quickstart exists.
- M2: Adapters return structured results; errors captured in receipts/.
- M3: Planner prints ≥3 actionable steps on fixture repo.
- M4: Fixture tests go green after minimal patches; no regressions.
- M5: Demo creates receipts/*/summary.md with diffs + rationale.

tasks/001_scaffold.md
# Task 001 — Scaffold
Create:
- pyproject.toml with dependencies: typer, pytest, ruff, black.
- src/mechanic/{cli.py,planner.py,receipts.py,sandbox.py,patches.py,guards.py}
- src/mechanic/tools/{shell.py,pytest_tool.py,ruff_tool.py,black_tool.py,uv_tool.py,git_tool.py}
- tests/{test_receipts.py,test_patches.py}
- fixtures/broken-calculator with 2 failing tests.
- README.md (Quickstart + architecture outline).
- .github/workflows/ci.yml to run lint + tests.

CLI: `repo-mechanic <path> [--fix-tests --lint --dry-run --max-steps 10]`
Receipts: JSONL steps + Markdown summary under receipts/<timestamp>/

tasks/002_tool_registry.md
# Task 002 — Tool Registry
Implement safe subprocess wrapper and adapters:
- shell.run(cmd:list, cwd:Path, timeout:int) -> {code, out, err}
- pytest_tool.run(path) -> {code, failures:[{file,line,msg}]}
- ruff_tool.run(path), black_tool.run(path, check:bool)
- uv_tool.ensure_env(path, requirements:optional)
- git_tool.init_and_commit(msg)

Add basic type hints and unit tests for receipts error handling.

bootstrap/prompt.txt
You are my agentic coding assistant. Load these files in order:
.agents/system.md
.agents/project_brief.md
.agents/constraints.md
.agents/tools.md
.agents/milestones.md
.agents/acceptance.md
tasks/001_scaffold.md

Then execute Task 001 with the following rules:
- Work only via unified diffs.
- After applying diffs, run `uv sync` then `uv run pytest -q`.
- On success, produce a commit with a clear message and write a summary plan to receipts/.
Acknowledge with a brief step plan before writing diffs.


You can add a tiny helper so you remember what to paste:

printf "%s\n" "Open bootstrap/prompt.txt in Codex and run it in this folder."

2) Start the Codex session (your first message)

Paste the full contents of bootstrap/prompt.txt into Codex/Copilot Chat while your terminal/editor is opened in the repo root.

If Codex can’t “read files”: paste the six .agents/*.md and tasks/001_scaffold.md contents directly into the chat first, then the last block of bootstrap/prompt.txt.

What Codex should reply with: a short step plan for Task 001.

Your next message to Codex (copy-paste):

Proceed with Task 001. Respond ONLY with unified diffs and the exact shell commands you will run. Keep patches minimal and typed. After creating files, run:
- uv sync
- uv run pytest -q
Then provide a receipts summary and a single commit. Begin.

3) Verify Task 001 locally

When Codex outputs diffs and commands, you (or it, if allowed) apply/run them. Then you run:

uv sync
uv run pytest -q
git status


You should see tests run (some may intentionally fail from fixtures), and files created. If something is off, tell Codex:

Tests executed with the following output (paste the last 50 lines).
Adjust patches until Task 001 acceptance is met. Reply with diffs only.

4) Move to Task 002 (tools)

Your prompt:

Load tasks/002_tool_registry.md and execute it.
Rules:
- Reply with a brief plan, then unified diffs only.
- After writing code, run: uv run pytest -q
- If failures reference missing functions, add minimal stubs with TODOs.
- Commit when `tests/test_receipts.py` and `tests/test_patches.py` pass.


Local check:

uv run pytest -q

5) Task 003 — Planner MVP

Create tasks/003_planner_mvp.md (or ask Codex to create it) with:

# Task 003 — Planner MVP
Implement:
- Parse pytest output into a Failure model.
- Generate a step plan: (a) run ruff/black on target, (b) suggest minimal file edits for top 2 failures, (c) re-run tests.
- CLI flags: --fix-tests, --lint, --dry-run, --max-steps
- receipts/: write JSONL steps + summary.md
Acceptance: running `uv run repo-mechanic fixtures/broken-calculator --fix-tests --max-steps 6` prints a plan and receipts, even if not all tests pass yet.


Prompt:

Execute Task 003. Diffs only. After code, run:
uv run repo-mechanic fixtures/broken-calculator --fix-tests --max-steps 6 --dry-run
uv run pytest -q
Commit when acceptance is met.

6) Task 004 — Patch engine + guards

Create tasks/004_patch_engine.md:

# Task 004 — Patch Engine + Guards
- Implement apply_unified_diff with:
  - allowlist (src/**, tests/**, fixtures/**)
  - max changed lines limit (200)
  - reject file renames/deletes for MVP
- Auto-revert last patch if tests regress (store pre-patch snapshot).
Acceptance: On fixture, minimal patches apply without breaking unrelated tests; receipts capture tool calls and diffs.


Prompt:

Execute Task 004. Diffs only. After code, run:
uv run repo-mechanic fixtures/broken-calculator --fix-tests --max-steps 6
uv run pytest -q
Commit on acceptance.

7) Task 005 — UX & Docs

Create tasks/005_receipts_and_docs.md:

# Task 005 — UX & Docs
- Typer help texts; README Quickstart + architecture diagram (ASCII ok).
- scripts/demo.sh to run a full demo end-to-end.
- .github/workflows/ci.yml to lint and run tests on push.
Acceptance: `bash scripts/demo.sh` finishes with receipts/*/summary.md and green tests for fixture.


Prompt:

Execute Task 005. Diffs only. After code, run:
bash scripts/demo.sh
uv run pytest -q
Commit on acceptance.

8) Final recruiter polish

Run locally:

ruff .
black --check .
uv run pytest -q


Then create a clean commit and fill the README with a before/after GIF (asciinema link OK) and the receipts sample path, plus a short “Why this repo matters for agentic coding” section.
****************************

